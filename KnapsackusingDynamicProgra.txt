# 0-1 Knapsack using Dynamic Programming (tabulation) with chosen items reconstruction

def knapsack_dp(weights, values, capacity):
    n = len(weights)
    # dp[i][w] = max value using first i items within capacity w
    dp = [[0]*(capacity+1) for _ in range(n+1)]

    for i in range(1, n+1):
        wt, val = weights[i-1], values[i-1]
        for w in range(capacity+1):
            if wt <= w:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-wt] + val)
            else:
                dp[i][w] = dp[i-1][w]

    # Reconstruct chosen items
    chosen = []
    w = capacity
    for i in range(n, 0, -1):
        if dp[i][w] != dp[i-1][w]:   # item i-1 was taken
            chosen.append(i-1)
            w -= weights[i-1]
    chosen.reverse()

    return dp[n][capacity], chosen


# ----------------- Demo -----------------
if __name__ == "__main__":
    weights = [2, 3, 4, 5]
    values  = [3, 4, 5, 6]
    capacity = 5

    best_value, chosen_idx = knapsack_dp(weights, values, capacity)
    print("DP -> Best value:", best_value)
    print("DP -> Chosen item indexes:", chosen_idx)
    print("DP -> Chosen (weight,value):", [(weights[i], values[i]) for i in chosen_idx])
